from typing import ClassVar, Dict, List
from sklearn.pipeline import Pipeline
from transformers import pipeline, logging


'''
Let M be a masked language model with vocab-
ulary V and mask token ∈ V , and let L be a
set of labels for our target classification task A.
We write an input for task A as a sequence of
phrases x = (s1 , . . . , sk ) with si ∈ V* ; for ex-
ample, k = 2 if A is textual inference (two input
sentences). We define a pattern to be a function P
that takes x as input and outputs a phrase or sen-
tence P (x) ∈ V* that contains exactly one mask
token, i.e., its output can be viewed as a cloze ques-
tion. Furthermore, we define a verbalizer as an
injective function v : L → V that maps each label
to a word from M's vocabulary. We refer to (P, v)
as a pattern-verbalizer pair (PVP).
'''

def unmask(s) -> str:
	ret_val = unmasker(s)
	return ret_val[0]['token_str']

class Pattern:
	# We write an input for task A as a sequence of 
	# phrases x = (s1 , . . . , sk ) with si ∈ V*
	phrases: ClassVar[List[str]]
	mask_index: ClassVar[int]

	def __init__(self, phrases: List[str], mask_index: int):
		self.phrases = phrases
		self.mask_index = mask_index

	# We define a pattern to be a function Pthat takes x as input and outputs a 
	# phrase or sentence P (x) ∈ V * that contains exactly one mask token
	def resolve(self) -> str:
		ret_val = ''
		masked = False
		for i in range(0, len(self.phrases) + 1):
			if i == self.mask_index:
				masked = True
				ret_val += '[MASK]'
			else:
				j = i
				if masked:
					j = i - 1
				ret_val += self.phrases[j]
		return ret_val

class Label:
	sentiment: ClassVar[str]
	values: ClassVar[List[str]]

	def __init__(self, sentiment: str):
		self.sentiment: str = sentiment
		self.values = []

	def add_value(self, value: str) -> None:
		if value in self.values:
			return
		self.values.append(value)

class Verbalizer:
	model = Pipeline
	labels: ClassVar[List[Label]]

	def __init__(self, labels: List[str], model: Pipeline):
		# [{ sentiment: String, values: [String] }]
		# let L be a set of labels for our target classification task A
		inst_labels = []
		for l in labels:
			inst_labels.append(Label(l))
		self.labels = inst_labels
		self.model = model

	def add_value(self, sentiment: str, value: str) -> None:
		for l in self.labels:
			if not l.sentiment == sentiment:
				continue
			l.add_value(value)
			return

	def analyze_sentiment(self, value) -> Label:
		for l in self.labels:
			if value not in l.values:
				continue
			return l
		model_ret = self.model(value)[0]['label']
		for l in self.labels:
			if not l.sentiment == model_ret:
				continue
			l.add_value(value)
			return l
		return None

	# we define a verbalizer as an injective function v : L → V that 
	# maps each label to a word from M's vocabulary.
	def get_label(self, value: str) -> str | None:
		for l in self.labels:
			if value in l.values:
				return l.sentiment
		return None

'''
Using a PVP (P, v) enables us to solve task A as
follows: Given an input x, we apply P to obtain an
input representation P (x), which is then processed
by M to determine the label y ∈ L for which
v(y) is the most likely substitute for the mask.
'''

# We refer to (P, v) as a pattern-verbalizer pair (PVP).
class PVP:
	model: ClassVar[Pipeline]
	verbalizer: ClassVar[Verbalizer]

	def __init__(self, model: Pipeline, verbalizer: Verbalizer):
		# Let M be a masked language model with vocabulary V and mask token ∈ V
		self.model = model
		self.verbalizer = verbalizer

	# Given an input x
	def run(self, pattern: Pattern) -> str:
		# we apply P to obtain an input representation P (x)
		p: str = pattern.resolve()
		# which is then processed by M to determine the label y ∈ L
		model_ret: str = unmask(p)
		# for which v(y) is the most likely substitute for the mask
		sentiment = self.verbalizer.analyze_sentiment(model_ret)
		return (sentiment.sentiment, model_ret)

logging.set_verbosity_error()
unmasker = pipeline('fill-mask', model='bert-base-uncased')
sentiment_analyzer = pipeline('sentiment-analysis')

v = Verbalizer(['POSITIVE', 'NEGATIVE'], sentiment_analyzer)
pvp = PVP(unmasker, v)
p = Pattern(['Mia likes pie?', ', Mia hates pie.'], 1)
print(pvp.run(p))